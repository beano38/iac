#!/usr/bin/python
import time
import random
from collections import OrderedDict

import jinja2

class FilterModule(object):
    def filters(self):
        return {
            'all_vars': self._all_vars,
            'join_devices': self._join_devices,
            'generate_links': self._generate_links,
            'build_topology': self.build_topology,
        }

    def _all_vars(self, hostnames, hostvars):
        # We need to take in all of the hostvars and put them in a list
        all_vars = []
        for host in hostnames:
            all_vars.append(hostvars[host])
        return all_vars

    def _join_devices(self, hostnames, hostvars):
        items = self._all_vars(hostnames, hostvars)
        # Use the hostvars from Ansible
        links = []
        link = {}

        for host in items:
            index = 0
            for interface in host["interfaces"]:
                interface["id"] = "i{}".format(index)  # For CML Topology file, needs to have a unique ID per device
                index += 1
                # Filter out any interface in CML or interconnects that doesn't have a cross-connect - i.e. Loopback Int
                if "remote_node_id" in interface:
                    link["id"] = host["id"]
                    link["hostname"] = host["hostname"]
                    link["type"] = interface["type"]
                    link["number"] = interface["number"]
                    link["remote_node_id"] = interface["remote_node_id"]
                    link["lid1"] = interface["id"]
                    links.append(dict(link))
        # Join the interconnects together by matching the remote node ID from host_vars
        for link in links:
            for host in items:
                index = 0
                # Match the two devices together
                if link["remote_node_id"] == host["id"]:
                    for interface in host["interfaces"]:
                        if "remote_node_id" in interface and interface["remote_node_id"] == link["id"]:
                            link["hostname2"] = host["hostname"]
                            link["type2"] = interface["type"]
                            link["number2"] = interface["number"]
                            link["lid2"] = "i{}".format(index)
                            index += 1

        return links

    def _generate_links(self, hostnames, hostvars):
        # generate the links dictionary that CML expects
        links = self._join_devices(hostnames, hostvars)
        final_link = {}
        final_links = []
        index = 0

        for link in links:
            try:
                final_link["id"] = "l{}".format(index)
                final_link["i1"] = link["lid1"]
                final_link["n1"] = "n{}".format(link["id"])
                final_link["i2"] = link["lid2"]
                final_link["n2"] = "n{}".format(link["remote_node_id"])
                index += 1
                final_links.append(dict(final_link))
            except KeyError:
                print("_generate_links KeyError {}".format(link))

        return final_links

    def _render_bootstrap_config(self, config_dict):
        env = jinja2.Environment(loader=jinja2.FileSystemLoader("./templates/configs"))

        try:
            bootstrap_template = env.get_template("{}/{}".format(config_dict["version"], config_dict["template"]))
        except jinja2.TemplateNotFound as err:
            print("Template not found {}".format(err))
            return

        config = bootstrap_template.render(config_dict)
        return config

    def build_topology(self, hostnames, hostvars):
        items = self._all_vars(hostnames, hostvars)
        topology_file = {
            "lab": {
                "description": "Test Topology generated by Ansible",
                "notes": "",
                "timestamp": int(time.time()),
                "title": "Test Topology",
                "version": "0.0.1"
            }
        }
        nodes = []
        node = {}
        for host in items:
            # Render bootstrap config
            configs_to_render = ["iosxrv9000"]
            if host["cml"]["node_def"].lower() in configs_to_render:
                try:
                    config_dict = {}
                    config_dict["template"] = host["render_config"]["template"]
                    config_dict["version"] = host["render_config"]["type"]
                    config_dict["hostname"] = host["hostname"].upper()
                    config_dict["vrf_name"] = host["management_network"]["vrf_name"]
                    config_dict["gateway"] = host["management_network"]["gateway"]
                    config_dict["aaa_hostname"] = host["aaa_config"]["hostname"]
                    config_dict["aaa_key"] = host["aaa_config"]["key"]
                    config = self._render_bootstrap_config(config_dict)
                except KeyError as err:
                    print("Render J2 KeyError {} error {}".format(host["hostname"], err))
                    config = ""

            node["id"] = "n{}".format(host["id"])
            node["label"] = host["hostname"].upper()
            node["node_definition"] = host["cml"]["node_def"]
            try:
                node["x"] = host["cords"]["x"]
            except KeyError:
                node["x"] = random.randint(-300, 300)
            try:
                node["y"] = host["cords"]["y"]
            except KeyError:
                node["y"] = random.randint(-300, 300)

            if host["cml"]["node_def"].lower() == "external_connector":
                node["configuration"] = "bridge1"
            else:
                node["configuration"] = "|-\n{}".format(config)
            try:
                node["image_definition"] = host["cml"]["image_def"]
            except KeyError:
                pass
            node["tags"] = []

            # Interface Stuff
            index = 0
            interface = {}
            interfaces = []
            for iface in host["interfaces"]:
                try:
                    interface["id"] = "i{}".format(index)
                    interface["slot"] = index
                    if host["cml"]["node_def"] == "external_connector":
                        interface["label"] = "port"
                    elif host["cml"]["node_def"] == "iosxrv9000":
                        # We need to renumber the interfaces since iosxr9000 definition only uses GE interfaces
                        interface["label"] = "GigabitEthernet0/0/0/{}".format(index)
                    else:
                        interface["label"] = "{}{}".format(iface["type"], iface["number"])
                    
                    if iface["type"].lower() == "loopback":
                        interface["type"] = "Loopback"
                    else:
                        interface["type"] = "physical"
                    index += 1
                    interfaces.append(dict(interface))
                except KeyError:
                    print("KeyError {}{}".format(host["hostname"], iface))
            node["interfaces"] = interfaces
            nodes.append(dict(node))

        topology_file["nodes"] = nodes
        topology_file["links"] = self._generate_links(hostnames, hostvars)

        return topology_file

